{"ast":null,"code":"var _jsxFileName = \"D:\\\\sa\\\\sort-visualizer\\\\src\\\\algorithms\\\\QuickSort3.js\";\nimport React from 'react';\nimport { swap, newTrace, addToTrace, lastSorted, createRange, createKey } from './helpers';\n\nconst QuickSort3 = nums => {\n  // Initial State\n  const trace = newTrace(nums);\n\n  function choosePivot(array, start, end) {\n    // randomly pick an element between start and end;\n    return Math.floor(Math.random() * (end - start)) + start;\n  }\n\n  function partition(array, start, end) {\n    const pivot = array[start];\n    let i = start + 1;\n    let j = start + 1;\n    let k = start + 1; // Between k and end : uncheked\n    // Between start and i : equal to pivot\n    // Between i and j : less than pivot\n    // Between j and k : greater than pivot\n    // Visualize: Keep pivot marked\n\n    addToTrace(trace, array, lastSorted(trace), [start]);\n\n    while (k < end) {\n      if (array[k] === pivot) {\n        // Visualize: Mark item that is equal to pivot\n        addToTrace(trace, array, lastSorted(trace), [start, ...createRange(start, i)], [k], [], createRange(i, j));\n        swap(array, i, k); // Visualize: Mark item that is equal to pivot\n\n        addToTrace(trace, array, lastSorted(trace), [start, ...createRange(start, i)], [i], [], createRange(i, j));\n        if (j > i) swap(array, j, k);\n        i += 1;\n        j += 1;\n      } else if (array[k] < pivot) {\n        // Visualize: Mark item that is less than pivot\n        addToTrace(trace, array, lastSorted(trace), [start, ...createRange(start, i)], [k], [], createRange(i, j));\n        swap(array, j, k); // Visualize: Move item to lesser list\n\n        addToTrace(trace, array, lastSorted(trace), [start, ...createRange(start, i)], [j], [], createRange(i, j));\n        j += 1;\n      }\n\n      k += 1;\n    }\n\n    const pivot_elements = i - start;\n    i -= 1;\n    j -= 1;\n\n    while (i >= start) {\n      swap(array, i, j);\n      i -= 1;\n      j -= 1;\n    } // Visualize: Move pivot_elements to center\n\n\n    addToTrace(trace, array, lastSorted(trace), createRange(j + 1, j + 1 + pivot_elements), [], [], createRange(start, j + 1));\n    return [j + 1, j + 1 + pivot_elements];\n  }\n\n  function recursiveQuickSort3(array, start, end) {\n    if (start >= end - 1) {\n      if (start === end - 1) {\n        // Visualize: Mark only item as sorted\n        addToTrace(trace, array, [...lastSorted(trace), start]);\n      }\n\n      return null;\n    }\n\n    let pivot = choosePivot(array, start, end); // Visualize: Mark chosen pivot\n\n    addToTrace(trace, array, lastSorted(trace), [pivot]);\n    swap(array, start, pivot); // Visualize: Move chosen pivot to start\n\n    addToTrace(trace, array, lastSorted(trace), [pivot]);\n    let [pivotStart, pivotEnd] = partition(array, start, end); // Visualize: Mark pivot after partition as sorted\n\n    addToTrace(trace, array, [...lastSorted(trace), ...createRange(pivotStart, pivotEnd)]);\n    recursiveQuickSort3(array, start, pivotStart);\n    recursiveQuickSort3(array, pivotEnd, end);\n  }\n\n  recursiveQuickSort3(nums, 0, nums.length);\n  return trace;\n};\n\nexport const QuickSort3Key = createKey('Comparing', 'Swapping', null, 'Less than pivot');\nexport const QuickSort3Desc = {\n  title: 'Quick Sort 3-Way Partitioning',\n  description: /*#__PURE__*/React.createElement(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 160,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 161,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"a\", {\n    href: \"https://en.wikipedia.org/wiki/Quicksort#Repeated_elements\",\n    target: \"_blank\",\n    rel: \"noopener noreferrer\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 162,\n      columnNumber: 9\n    }\n  }, \"Quick Sort\"), ' ', \"exhibits poor performance on arrays that contain many repeated elements. This issue (\", /*#__PURE__*/React.createElement(\"a\", {\n    href: \"https://en.wikipedia.org/wiki/Dutch_national_flag_problem\",\n    target: \"_blank\",\n    rel: \"noopener noreferrer\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 171,\n      columnNumber: 9\n    }\n  }, \"Dutch national flag problem\"), \") can be solved by using an alternative linear-time partitioning routine that separates the values into three groups: values less than the pivot, values equal to the pivot, and values greater than the pivot. The values equal to the pivot are already sorted, so only the less-than and greater-than partitions need to be recursively sorted.\")),\n  worstCase: /*#__PURE__*/React.createElement(\"span\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 188,\n      columnNumber: 5\n    }\n  }, \"O(\", /*#__PURE__*/React.createElement(\"em\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 189,\n      columnNumber: 9\n    }\n  }, \"n\"), /*#__PURE__*/React.createElement(\"sup\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 190,\n      columnNumber: 7\n    }\n  }, \"2\"), \")\"),\n  avgCase: /*#__PURE__*/React.createElement(\"span\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 194,\n      columnNumber: 5\n    }\n  }, \"O(\", /*#__PURE__*/React.createElement(\"em\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 195,\n      columnNumber: 9\n    }\n  }, \"n\"), \" log \", /*#__PURE__*/React.createElement(\"em\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 195,\n      columnNumber: 24\n    }\n  }, \"n\"), \")\"),\n  bestCase: /*#__PURE__*/React.createElement(\"span\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 199,\n      columnNumber: 5\n    }\n  }, \"O(\", /*#__PURE__*/React.createElement(\"em\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 200,\n      columnNumber: 9\n    }\n  }, \"n\"), \")\"),\n  space: /*#__PURE__*/React.createElement(\"span\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 204,\n      columnNumber: 5\n    }\n  }, \"O(log \", /*#__PURE__*/React.createElement(\"em\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 205,\n      columnNumber: 13\n    }\n  }, \"n\"), \")\")\n};\nexport default QuickSort3;","map":{"version":3,"sources":["D:/sa/sort-visualizer/src/algorithms/QuickSort3.js"],"names":["React","swap","newTrace","addToTrace","lastSorted","createRange","createKey","QuickSort3","nums","trace","choosePivot","array","start","end","Math","floor","random","partition","pivot","i","j","k","pivot_elements","recursiveQuickSort3","pivotStart","pivotEnd","length","QuickSort3Key","QuickSort3Desc","title","description","worstCase","avgCase","bestCase","space"],"mappings":"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","sourcesContent":["import React from 'react';\r\nimport {\r\n  swap,\r\n  newTrace,\r\n  addToTrace,\r\n  lastSorted,\r\n  createRange,\r\n  createKey\r\n} from './helpers';\r\n\r\nconst QuickSort3 = (nums) => {\r\n  // Initial State\r\n  const trace = newTrace(nums);\r\n\r\n  function choosePivot(array, start, end) {\r\n    // randomly pick an element between start and end;\r\n    return Math.floor(Math.random() * (end - start)) + start;\r\n  }\r\n\r\n  function partition(array, start, end) {\r\n    const pivot = array[start];\r\n    let i = start + 1;\r\n    let j = start + 1;\r\n    let k = start + 1;\r\n    // Between k and end : uncheked\r\n    // Between start and i : equal to pivot\r\n    // Between i and j : less than pivot\r\n    // Between j and k : greater than pivot\r\n\r\n    // Visualize: Keep pivot marked\r\n    addToTrace(trace, array, lastSorted(trace), [start]);\r\n\r\n    while (k < end) {\r\n      if (array[k] === pivot) {\r\n        // Visualize: Mark item that is equal to pivot\r\n        addToTrace(\r\n          trace,\r\n          array,\r\n          lastSorted(trace),\r\n          [start, ...createRange(start, i)],\r\n          [k],\r\n          [],\r\n          createRange(i, j)\r\n        );\r\n\r\n        swap(array, i, k);\r\n\r\n        // Visualize: Mark item that is equal to pivot\r\n        addToTrace(\r\n          trace,\r\n          array,\r\n          lastSorted(trace),\r\n          [start, ...createRange(start, i)],\r\n          [i],\r\n          [],\r\n          createRange(i, j)\r\n        );\r\n\r\n        if (j > i) swap(array, j, k);\r\n        i += 1;\r\n        j += 1;\r\n      } else if (array[k] < pivot) {\r\n        // Visualize: Mark item that is less than pivot\r\n        addToTrace(\r\n          trace,\r\n          array,\r\n          lastSorted(trace),\r\n          [start, ...createRange(start, i)],\r\n          [k],\r\n          [],\r\n          createRange(i, j)\r\n        );\r\n\r\n        swap(array, j, k);\r\n\r\n        // Visualize: Move item to lesser list\r\n        addToTrace(\r\n          trace,\r\n          array,\r\n          lastSorted(trace),\r\n          [start, ...createRange(start, i)],\r\n          [j],\r\n          [],\r\n          createRange(i, j)\r\n        );\r\n\r\n        j += 1;\r\n      }\r\n      k += 1;\r\n    }\r\n\r\n    const pivot_elements = i - start;\r\n    i -= 1;\r\n    j -= 1;\r\n    while (i >= start) {\r\n      swap(array, i, j);\r\n      i -= 1;\r\n      j -= 1;\r\n    }\r\n\r\n    // Visualize: Move pivot_elements to center\r\n    addToTrace(\r\n      trace,\r\n      array,\r\n      lastSorted(trace),\r\n      createRange(j + 1, j + 1 + pivot_elements),\r\n      [],\r\n      [],\r\n      createRange(start, j + 1)\r\n    );\r\n    return [j + 1, j + 1 + pivot_elements];\r\n  }\r\n\r\n  function recursiveQuickSort3(array, start, end) {\r\n    if (start >= end - 1) {\r\n      if (start === end - 1) {\r\n        // Visualize: Mark only item as sorted\r\n        addToTrace(trace, array, [...lastSorted(trace), start]);\r\n      }\r\n      return null;\r\n    }\r\n\r\n    let pivot = choosePivot(array, start, end);\r\n\r\n    // Visualize: Mark chosen pivot\r\n    addToTrace(trace, array, lastSorted(trace), [pivot]);\r\n\r\n    swap(array, start, pivot);\r\n\r\n    // Visualize: Move chosen pivot to start\r\n    addToTrace(trace, array, lastSorted(trace), [pivot]);\r\n\r\n    let [pivotStart, pivotEnd] = partition(array, start, end);\r\n\r\n    // Visualize: Mark pivot after partition as sorted\r\n    addToTrace(trace, array, [\r\n      ...lastSorted(trace),\r\n      ...createRange(pivotStart, pivotEnd)\r\n    ]);\r\n\r\n    recursiveQuickSort3(array, start, pivotStart);\r\n    recursiveQuickSort3(array, pivotEnd, end);\r\n  }\r\n\r\n  recursiveQuickSort3(nums, 0, nums.length);\r\n\r\n  return trace;\r\n};\r\n\r\nexport const QuickSort3Key = createKey(\r\n  'Comparing',\r\n  'Swapping',\r\n  null,\r\n  'Less than pivot'\r\n);\r\n\r\nexport const QuickSort3Desc = {\r\n  title: 'Quick Sort 3-Way Partitioning',\r\n  description: (\r\n    <div>\r\n      <p>\r\n        <a\r\n          href=\"https://en.wikipedia.org/wiki/Quicksort#Repeated_elements\"\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n        >\r\n          Quick Sort\r\n        </a>{' '}\r\n        exhibits poor performance on arrays that contain many repeated\r\n        elements. This issue (\r\n        <a\r\n          href=\"https://en.wikipedia.org/wiki/Dutch_national_flag_problem\"\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n        >\r\n          Dutch national flag problem\r\n        </a>\r\n        ) can be solved by using an alternative linear-time partitioning\r\n        routine that separates the values into three groups: values less\r\n        than the pivot, values equal to the pivot, and values greater\r\n        than the pivot. The values equal to the pivot are already\r\n        sorted, so only the less-than and greater-than partitions need\r\n        to be recursively sorted.\r\n      </p>\r\n    </div>\r\n  ),\r\n  worstCase: (\r\n    <span>\r\n      O(<em>n</em>\r\n      <sup>2</sup>)\r\n    </span>\r\n  ),\r\n  avgCase: (\r\n    <span>\r\n      O(<em>n</em> log <em>n</em>)\r\n    </span>\r\n  ),\r\n  bestCase: (\r\n    <span>\r\n      O(<em>n</em>)\r\n    </span>\r\n  ),\r\n  space: (\r\n    <span>\r\n      O(log <em>n</em>)\r\n    </span>\r\n  )\r\n};\r\n\r\nexport default QuickSort3;\r\n"]},"metadata":{},"sourceType":"module"}