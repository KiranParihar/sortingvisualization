{"ast":null,"code":"var _jsxFileName = \"D:\\\\sa\\\\sort-visualizer\\\\src\\\\algorithms\\\\MergeSort.js\";\nimport React from 'react';\nimport { newTrace, addToTrace, createKey } from './helpers';\n\nconst MergeSort = nums => {\n  // Initial State\n  const trace = newTrace(nums);\n\n  function merge(original, start, mid, end) {\n    const left = original.slice(start, mid);\n    const right = original.slice(mid, end);\n    let i = 0;\n    let j = 0;\n    let k = 0;\n\n    while (i < left.length && j < right.length) {\n      if (left[i] <= right[j]) {\n        addToTrace(trace, original, [], [], [], [k + start]);\n        original[k + start] = left[i];\n        i++;\n        addToTrace(trace, original, [], [], [], [k + start]);\n      } else {\n        addToTrace(trace, original, [], [], [], [k + start]);\n        original[k + start] = right[j];\n        j++;\n        addToTrace(trace, original, [], [], [], [k + start]);\n      }\n\n      k++;\n    }\n\n    while (i < left.length) {\n      addToTrace(trace, original, [], [], [], [k + start]);\n      original[k + start] = left[i];\n      i++;\n      k++;\n      addToTrace(trace, original, [], [], [], [k + start]);\n    }\n\n    while (j < right.length) {\n      addToTrace(trace, original, [], [], [], [k + start]);\n      original[k + start] = right[j];\n      j++;\n      k++;\n      addToTrace(trace, original, [], [], [], [k + start]);\n    }\n\n    left.length = 0;\n    right.length = 0;\n  }\n\n  function recursiveMergeSort(original, start, end) {\n    const length = end - start;\n\n    if (length < 2) {\n      // original = []\n      if (length < 1) return original; // original = [x]\n      else return [original[start]];\n    }\n\n    const midPoint = Math.floor((start + end) / 2); // Visualize: First Half\n\n    addToTrace(trace, original, [], [...Array(midPoint - start).keys()].map(i => i + start));\n    recursiveMergeSort(original, start, midPoint); // Visualize: Second Half\n\n    addToTrace(trace, original, [], [...Array(end - midPoint).keys()].map(i => i + midPoint));\n    recursiveMergeSort(original, midPoint, end);\n    merge(original, start, midPoint, end);\n  }\n\n  recursiveMergeSort(nums, 0, nums.length); // Visualize: Mark all elements as sorted\n\n  addToTrace(trace, nums, [...Array(nums.length).keys()]);\n  return trace;\n};\n\nexport const MergeSortKey = createKey('Call Merge Sort', null, 'Overwrite from axillary array');\nexport const MergeSortDesc = {\n  title: 'Merge Sort',\n  description: /*#__PURE__*/React.createElement(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 94,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 95,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"a\", {\n    href: \"https://en.wikipedia.org/wiki/Merge_sort\",\n    target: \"_blank\",\n    rel: \"noopener noreferrer\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 96,\n      columnNumber: 9\n    }\n  }, \"Merge Sort\"), ' ', \"is an efficient, stable sorting algorith that makes use of the divide and conquer strategy. Conceptually the algorithm works as follows:\"), /*#__PURE__*/React.createElement(\"ol\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 107,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 108,\n      columnNumber: 9\n    }\n  }, \"Divide the unsorted list into \", /*#__PURE__*/React.createElement(\"em\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 109,\n      columnNumber: 41\n    }\n  }, \"n\"), \" sublists, each containing one element(a list of one element is considered sorted)\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 113,\n      columnNumber: 9\n    }\n  }, \"Repeatedly merge sublists to produce new sorted sublists until there is only one sublist remaining. This will be the sorted list.\"))),\n  worstCase: /*#__PURE__*/React.createElement(\"span\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 122,\n      columnNumber: 5\n    }\n  }, \"O(\", /*#__PURE__*/React.createElement(\"em\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 123,\n      columnNumber: 9\n    }\n  }, \"n\"), \" log \", /*#__PURE__*/React.createElement(\"em\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 123,\n      columnNumber: 24\n    }\n  }, \"n\"), \")\"),\n  avgCase: /*#__PURE__*/React.createElement(\"span\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 127,\n      columnNumber: 5\n    }\n  }, \"O(\", /*#__PURE__*/React.createElement(\"em\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 128,\n      columnNumber: 9\n    }\n  }, \"n\"), \" log \", /*#__PURE__*/React.createElement(\"em\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 128,\n      columnNumber: 24\n    }\n  }, \"n\"), \")\"),\n  bestCase: /*#__PURE__*/React.createElement(\"span\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 132,\n      columnNumber: 5\n    }\n  }, \"O(\", /*#__PURE__*/React.createElement(\"em\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 133,\n      columnNumber: 9\n    }\n  }, \"n\"), \" log \", /*#__PURE__*/React.createElement(\"em\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 133,\n      columnNumber: 24\n    }\n  }, \"n\"), \")\"),\n  space: /*#__PURE__*/React.createElement(\"span\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 137,\n      columnNumber: 5\n    }\n  }, \"O(\", /*#__PURE__*/React.createElement(\"em\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 138,\n      columnNumber: 9\n    }\n  }, \"n\"), \")\")\n};\nexport default MergeSort;","map":{"version":3,"sources":["D:/sa/sort-visualizer/src/algorithms/MergeSort.js"],"names":["React","newTrace","addToTrace","createKey","MergeSort","nums","trace","merge","original","start","mid","end","left","slice","right","i","j","k","length","recursiveMergeSort","midPoint","Math","floor","Array","keys","map","MergeSortKey","MergeSortDesc","title","description","worstCase","avgCase","bestCase","space"],"mappings":"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","sourcesContent":["import React from 'react';\r\nimport { newTrace, addToTrace, createKey } from './helpers';\r\n\r\nconst MergeSort = (nums) => {\r\n  // Initial State\r\n  const trace = newTrace(nums);\r\n\r\n  function merge(original, start, mid, end) {\r\n    const left = original.slice(start, mid);\r\n    const right = original.slice(mid, end);\r\n    let i = 0;\r\n    let j = 0;\r\n    let k = 0;\r\n    while (i < left.length && j < right.length) {\r\n      if (left[i] <= right[j]) {\r\n        addToTrace(trace, original, [], [], [], [k + start]);\r\n        original[k + start] = left[i];\r\n        i++;\r\n        addToTrace(trace, original, [], [], [], [k + start]);\r\n      } else {\r\n        addToTrace(trace, original, [], [], [], [k + start]);\r\n        original[k + start] = right[j];\r\n        j++;\r\n        addToTrace(trace, original, [], [], [], [k + start]);\r\n      }\r\n      k++;\r\n    }\r\n    while (i < left.length) {\r\n      addToTrace(trace, original, [], [], [], [k + start]);\r\n      original[k + start] = left[i];\r\n      i++;\r\n      k++;\r\n      addToTrace(trace, original, [], [], [], [k + start]);\r\n    }\r\n    while (j < right.length) {\r\n      addToTrace(trace, original, [], [], [], [k + start]);\r\n      original[k + start] = right[j];\r\n      j++;\r\n      k++;\r\n      addToTrace(trace, original, [], [], [], [k + start]);\r\n    }\r\n\r\n    left.length = 0;\r\n    right.length = 0;\r\n  }\r\n\r\n  function recursiveMergeSort(original, start, end) {\r\n    const length = end - start;\r\n    if (length < 2) {\r\n      // original = []\r\n      if (length < 1) return original;\r\n      // original = [x]\r\n      else return [original[start]];\r\n    }\r\n\r\n    const midPoint = Math.floor((start + end) / 2);\r\n\r\n    // Visualize: First Half\r\n    addToTrace(\r\n      trace,\r\n      original,\r\n      [],\r\n      [...Array(midPoint - start).keys()].map((i) => i + start)\r\n    );\r\n    recursiveMergeSort(original, start, midPoint);\r\n\r\n    // Visualize: Second Half\r\n    addToTrace(\r\n      trace,\r\n      original,\r\n      [],\r\n      [...Array(end - midPoint).keys()].map((i) => i + midPoint)\r\n    );\r\n    recursiveMergeSort(original, midPoint, end);\r\n\r\n    merge(original, start, midPoint, end);\r\n  }\r\n\r\n  recursiveMergeSort(nums, 0, nums.length);\r\n\r\n  // Visualize: Mark all elements as sorted\r\n  addToTrace(trace, nums, [...Array(nums.length).keys()]);\r\n  return trace;\r\n};\r\n\r\nexport const MergeSortKey = createKey(\r\n  'Call Merge Sort',\r\n  null,\r\n  'Overwrite from axillary array'\r\n);\r\nexport const MergeSortDesc = {\r\n  title: 'Merge Sort',\r\n  description: (\r\n    <div>\r\n      <p>\r\n        <a\r\n          href=\"https://en.wikipedia.org/wiki/Merge_sort\"\r\n          target=\"_blank\"\r\n          rel=\"noopener noreferrer\"\r\n        >\r\n          Merge Sort\r\n        </a>{' '}\r\n        is an efficient, stable sorting algorith that makes use of the\r\n        divide and conquer strategy. Conceptually the algorithm works as\r\n        follows:\r\n      </p>\r\n      <ol>\r\n        <li>\r\n          Divide the unsorted list into <em>n</em> sublists, each\r\n          containing one element(a list of one element is considered\r\n          sorted)\r\n        </li>\r\n        <li>\r\n          Repeatedly merge sublists to produce new sorted sublists until\r\n          there is only one sublist remaining. This will be the sorted\r\n          list.\r\n        </li>\r\n      </ol>\r\n    </div>\r\n  ),\r\n  worstCase: (\r\n    <span>\r\n      O(<em>n</em> log <em>n</em>)\r\n    </span>\r\n  ),\r\n  avgCase: (\r\n    <span>\r\n      O(<em>n</em> log <em>n</em>)\r\n    </span>\r\n  ),\r\n  bestCase: (\r\n    <span>\r\n      O(<em>n</em> log <em>n</em>)\r\n    </span>\r\n  ),\r\n  space: (\r\n    <span>\r\n      O(<em>n</em>)\r\n    </span>\r\n  )\r\n};\r\nexport default MergeSort;\r\n"]},"metadata":{},"sourceType":"module"}